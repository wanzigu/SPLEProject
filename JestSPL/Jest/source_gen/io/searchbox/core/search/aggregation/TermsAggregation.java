package io.searchbox.core.search.aggregation;

/*Generated by MPS */

import java.util.List;
import java.util.LinkedList;
import com.google.gson.JsonObject;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;

public class TermsAggregation extends BucketAggregation {

  public static final String TYPE = "terms";
  private Long docCountErrorUpperBound;
  private Long sumOtherDocCount;
  private List<TermsAggregation.Entry> buckets = new LinkedList<TermsAggregation.Entry>();
  public TermsAggregation(String name, JsonObject termAggregation) {
    super(name, termAggregation);
    if (termAggregation.has(String.valueOf(AggregationField.DOC_COUNT_ERROR_UPPER_BOUND))) {
      docCountErrorUpperBound = termAggregation.get(String.valueOf(AggregationField.DOC_COUNT_ERROR_UPPER_BOUND)).getAsLong();
    }
    if (termAggregation.has(String.valueOf(AggregationField.SUM_OTHER_DOC_COUNT))) {
      sumOtherDocCount = termAggregation.get(String.valueOf(AggregationField.SUM_OTHER_DOC_COUNT)).getAsLong();
    }
    if (termAggregation.has(String.valueOf(AggregationField.BUCKETS)) && termAggregation.get(String.valueOf(AggregationField.BUCKETS)).isJsonArray()) {
      parseBuckets(termAggregation.get(String.valueOf(AggregationField.BUCKETS)).getAsJsonArray());
    }
  }
  private void parseBuckets(JsonArray bucketsSource) {
    for (JsonElement bucketElement : bucketsSource) {
      JsonObject bucket = (JsonObject) bucketElement;
      if (bucket.has(String.valueOf(AggregationField.KEY_AS_STRING))) {
        buckets.add(new TermsAggregation.Entry(bucket, bucket.get(String.valueOf(AggregationField.KEY)).getAsString(), bucket.get(String.valueOf(AggregationField.KEY_AS_STRING)).getAsString(), bucket.get(String.valueOf(AggregationField.DOC_COUNT)).getAsLong()));
      } else {
        buckets.add(new TermsAggregation.Entry(bucket, bucket.get(String.valueOf(AggregationField.KEY)).getAsString(), bucket.get(String.valueOf(AggregationField.DOC_COUNT)).getAsLong()));
      }
    }
  }
  public Long getDocCountErrorUpperBound() {
    return docCountErrorUpperBound;
  }
  public Long getSumOtherDocCount() {
    return sumOtherDocCount;
  }
  public List<TermsAggregation.Entry> getBuckets() {
    return buckets;
  }
  public class Entry extends Bucket {
    private String key;
    private String keyAsString;
    public Entry(JsonObject bucket, String key, Long count) {
      this(bucket, key, key, count);
    }
    public Entry(JsonObject bucket, String key, String keyAsString, Long count) {
      super(bucket, count);
      this.key = key;
      this.keyAsString = keyAsString;
    }
    public String getKey() {
      return key;
    }
    public String getKeyAsString() {
      return keyAsString;
    }
    @Override
    public boolean equals(Object obj) {
      if (obj == null) {
        return false;
      }
      if (obj == this) {
        return true;
      }
      if (obj.getClass() != getClass()) {
        return false;
      }
      TermsAggregation.Entry rhs = (TermsAggregation.Entry) obj;
      return new EqualsBuilder().appendSuper(super.equals(obj)).append(key, rhs.key).append(keyAsString, rhs.keyAsString).isEquals();
    }
    @Override
    public int hashCode() {
      return new HashCodeBuilder().append(getCount()).append(getKey()).append(keyAsString).toHashCode();
    }
  }
  @Override
  public boolean equals(Object obj) {
    if (obj == null) {
      return false;
    }
    if (obj == this) {
      return true;
    }
    if (obj.getClass() != getClass()) {
      return false;
    }
    TermsAggregation rhs = (TermsAggregation) obj;
    return new EqualsBuilder().appendSuper(super.equals(obj)).append(buckets, rhs.buckets).append(docCountErrorUpperBound, rhs.docCountErrorUpperBound).append(sumOtherDocCount, rhs.sumOtherDocCount).isEquals();
  }
  @Override
  public int hashCode() {
    return new HashCodeBuilder().appendSuper(super.hashCode()).append(docCountErrorUpperBound).append(sumOtherDocCount).append(buckets).toHashCode();
  }
}
