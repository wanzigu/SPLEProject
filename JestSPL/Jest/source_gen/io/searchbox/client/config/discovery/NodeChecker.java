package io.searchbox.client.config.discovery;

/*Generated by MPS */

import com.google.common.util.concurrent.AbstractScheduledService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.regex.Pattern;
import io.searchbox.cluster.NodesInfo;
import io.searchbox.client.JestClient;
import java.util.Set;
import io.searchbox.client.config.ClientConfig;
import com.google.common.collect.ImmutableSet;
import io.searchbox.client.JestResult;
import io.searchbox.client.config.exception.CouldNotConnectException;
import java.util.LinkedHashSet;
import com.google.gson.JsonObject;
import java.util.Map;
import com.google.gson.JsonElement;
import org.apache.commons.lang3.StringUtils;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.Executors;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.google.common.util.concurrent.Service;
import com.google.common.util.concurrent.MoreExecutors;
import java.util.regex.Matcher;

public class NodeChecker extends AbstractScheduledService {

  private static final Logger log = LoggerFactory.getLogger(NodeChecker.class);
  private static final String PUBLISH_ADDRESS_KEY = "http_address";
  private static final Pattern INETSOCKETADDRESS_PATTERN = Pattern.compile("(?:inet\\[)?(?:(?:[^:]+)?\\/)?([^:]+):(\\d+)\\]?");
  private final NodesInfo action;
  protected JestClient client;
  protected AbstractScheduledService.Scheduler scheduler;
  protected String defaultScheme;
  protected Set<String> bootstrapServerList;
  protected Set<String> discoveredServerList;
  public NodeChecker(JestClient jestClient, ClientConfig clientConfig) {
    action = new NodesInfo.Builder().withHttp().addNode(clientConfig.getDiscoveryFilter()).build();
    this.client = jestClient;
    this.defaultScheme = clientConfig.getDefaultSchemeForDiscoveredNodes();
    this.scheduler = AbstractScheduledService.Scheduler.newFixedDelaySchedule(0L, clientConfig.getDiscoveryFrequency(), clientConfig.getDiscoveryFrequencyTimeUnit());
    this.bootstrapServerList = ImmutableSet.copyOf(clientConfig.getServerList());
  }
  @Override
  protected void runOneIteration() throws Exception {
    JestResult result;
    try {
      result = client.execute(action);
    } catch (CouldNotConnectException cnce) {
      // Can't connect to this node, remove it from the list 
      log.error("Connect exception executing NodesInfo!", cnce);
      removeNodeAndUpdateServers(cnce.getHost());
      return;
      // do not elevate the exception since that will stop the scheduled calls. 
      // throw new RuntimeException("Error executing NodesInfo!", e); 
    } catch (Exception e) {
      log.error("Error executing NodesInfo!", e);
      client.setServers(bootstrapServerList);
      return;
      // do not elevate the exception since that will stop the scheduled calls. 
      // throw new RuntimeException("Error executing NodesInfo!", e); 
    }
    if (result.isSucceeded()) {
      LinkedHashSet<String> httpHosts = new LinkedHashSet<String>();
      JsonObject jsonMap = result.getJsonObject();
      JsonObject nodes = (JsonObject) jsonMap.get("nodes");
      if (nodes != null) {
        for (Map.Entry<String, JsonElement> entry : nodes.entrySet()) {
          JsonObject host = entry.getValue().getAsJsonObject();
          // get as a JsonElement first as some nodes in the cluster may not have an http_address 
          if (host.has(PUBLISH_ADDRESS_KEY)) {
            JsonElement addressElement = host.get(PUBLISH_ADDRESS_KEY);
            if (!(addressElement.isJsonNull())) {
              String httpAddress = getHttpAddress(addressElement.getAsString());
              if (httpAddress != null) {
                httpHosts.add(httpAddress);
              }
            }
          }
        }
      }
      if (log.isDebugEnabled()) {
        log.debug("Discovered {} HTTP hosts: {}", httpHosts.size(), StringUtils.join(httpHosts, ","));
      }
      discoveredServerList = httpHosts;
      client.setServers(discoveredServerList);
    } else {
      log.warn("NodesInfo request resulted in error: {}", result.getErrorMessage());
      client.setServers(bootstrapServerList);
    }
  }
  protected void removeNodeAndUpdateServers(final String hostToRemove) {
    log.warn("Removing host {}", hostToRemove);
    discoveredServerList.remove(hostToRemove);
    if (log.isInfoEnabled()) {
      log.info("Discovered server pool is now: {}", StringUtils.join(discoveredServerList, ","));
    }
    if (!(discoveredServerList.isEmpty())) {
      client.setServers(discoveredServerList);
    } else {
      client.setServers(bootstrapServerList);
    }
  }
  @Override
  protected AbstractScheduledService.Scheduler scheduler() {
    return scheduler;
  }
  @Override
  protected ScheduledExecutorService executor() {
    final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryBuilder().setDaemon(true).setNameFormat(serviceName()).build());
    // Add a listener to shutdown the executor after the service is stopped.  This ensures that the 
    // JVM shutdown will not be prevented from exiting after this service has stopped or failed. 
    // Technically this listener is added after start() was called so it is a little gross, but it 
    // is called within doStart() so we know that the service cannot terminate or fail concurrently 
    // with adding this listener so it is impossible to miss an event that we are interested in. 
    addListener(new Service.Listener() {
      @Override
      public void terminated(Service.State from) {
        executor.shutdown();
      }
      @Override
      public void failed(Service.State from, Throwable failure) {
        executor.shutdown();
      }
    }, MoreExecutors.directExecutor());
    return executor;
  }
  /**
   * Converts the Elasticsearch reported publish address in the format "inet[<hostname>:<port>]" or
   * "inet[<hostname>/<hostaddress>:<port>]" to a normalized http address in the form "http://host:port".
   */
  protected String getHttpAddress(String httpAddress) {
    Matcher resolvedMatcher = INETSOCKETADDRESS_PATTERN.matcher(httpAddress);
    if (resolvedMatcher.matches()) {
      return defaultScheme + resolvedMatcher.group(1) + ":" + resolvedMatcher.group(2);
    }
    return null;
  }
}
